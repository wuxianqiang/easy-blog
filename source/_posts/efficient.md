---
title: 高效使用内存
date: 2019-06-30 20:58:49
tags: Node
---

{% asset_img banner.png 图片 %}

高效使用内存是表示让垃圾回收机制更高效的工作。

当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。

<!-- more -->

内存分配之后是要回收的，如果不回收就一直占用内存，超出了内存的最大值，就会内存泄漏。所有我们要理解垃圾回收。什么情况会触发垃圾回收呢？

## 作用域

在JavaScript中能形成作用域的有函数调用、 `with` 以及全局作用域。

```js
const foo = function () {
  const local = {};
};
```

`foo()` 函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短。在这个示例中，由于对象非常小，将会分配在新生代中的 From 空间中。在作用域释放后，局部变量 `local` 失效，其引用的对象将会在下次垃圾回收时被释放。

## 主动释放

如果变量是全局变量（定义在 global 变量上），由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存的对象，可以通过 `delete` 操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理的过程中，会被回收释放。下面为示例代码：

```js
global.foo = "I am global object";
console.log(global.foo); // => "I am global object"
delete global.foo;
// 或者重新赋值
global.foo = undefined; // or null
console.log(global.foo); // => undefined
```

虽然 delete 操作和重新赋值具有相同的效果，但是在V8中通过 `delete` 删除对象的属性有可能干扰V8的优化，所以通过赋值方式解除引用更好。
